#include "Lights.h"

using namespace metal;

namespace bloom {
	
	/// MARK: Lights
	float3 calculatePointLight(PBRData pbrData, PointLight light, float3 V, float3 N, float3 worldPosition) {
		float3 const L = normalize(light.position - worldPosition);
		float3 const H = normalize(V + L);
		
		float const dist = max(length(light.position - worldPosition) - light.radius, 0.0001);
		float const attenuation = 1.0 / (dist * dist);
		
		float3 const radiance = light.common.color * light.common.intensity * attenuation;
		
		return PBRLighting(pbrData, radiance, N, V, L, H);
	}

	float3 calculateSpotlight(PBRData pbrData, SpotLight light, float3 V, float3 N, float3 worldPosition) {
		float3 const L = normalize(light.position - worldPosition);
		
		float const theta     = dot(L, -light.direction);
		float const epsilon   = light.innerCutoff - light.outerCutoff;
		float const intensity = clamp((theta - light.outerCutoff) / epsilon, 0.0, 1.0);
		
		if (theta == 0) {
			return 0;
		}
		
		float3 const H = normalize(V + L);
		
		float const dist = max(length(light.position - worldPosition) - light.radius, 0.0001);
		float const attenuation = 1.0 / (dist * dist);
		
		float3 const radiance = intensity * light.common.color * light.common.intensity * attenuation;
		
		return PBRLighting(pbrData, radiance, N, V, L, H);
	}

	float3 calculateDirectionalLight(PBRData pbrData, DirectionalLight light, float3 V, float3 N) {
		float3 const L = light.direction;
		float3 const H = normalize(V + L);
		float3 const radiance = light.common.color * light.common.intensity;

		return PBRLighting(pbrData, radiance, N, V, L, H);
	}
	
	/// MARK: Shadows
	static bool isInLightFrustum(float3 const projCoords) {
		bool3 const result = projCoords >= 0 && projCoords <= 1;
		return result.x && result.y && result.z;
	}

	static float3 calculateLightProjection(float4 const positionLightSpace) {
		// perform perspective divide
		float3 projCoords = positionLightSpace.xyz / positionLightSpace.w;
		projCoords.y *= -1;
		projCoords.xy = projCoords.xy * 0.5 + 0.5;
		return projCoords;
	}
	
	
	float2 constant PoissonOffsets[32] = {
		float2(0.06407013, 0.05409927),
		float2(0.7366577, 0.5789394),
		float2(-0.6270542, -0.5320278),
		float2(-0.4096107, 0.8411095),
		float2(0.6849564, -0.4990818),
		float2(-0.874181, -0.04579735),
		float2(0.9989998, 0.0009880066),
		float2(-0.004920578, -0.9151649),
		float2(0.1805763, 0.9747483),
		float2(-0.2138451, 0.2635818),
		float2(0.109845, 0.3884785),
		float2(0.06876755, -0.3581074),
		float2(0.374073, -0.7661266),
		float2(0.3079132, -0.1216763),
		float2(-0.3794335, -0.8271583),
		float2(-0.203878, -0.07715034),
		float2(0.5912697, 0.1469799),
		float2(-0.88069, 0.3031784),
		float2(0.5040108, 0.8283722),
		float2(-0.5844124, 0.5494877),
		float2(0.6017799, -0.1726654),
		float2(-0.5554981, 0.1559997),
		float2(-0.3016369, -0.3900928),
		float2(-0.5550632, -0.1723762),
		float2(0.925029, 0.2995041),
		float2(-0.2473137, 0.5538505),
		float2(0.9183037, -0.2862392),
		float2(0.2469421, 0.6718712),
		float2(0.3916397, -0.4328209),
		float2(-0.03576927, -0.6220032),
		float2(-0.04661255, 0.7995201),
		float2(0.4402924, 0.3640312),
	};
	
	static float2 rotate_(float2 pos, float2 rotationTrig)
	{
		return float2(pos.x * rotationTrig.x - pos.y * rotationTrig.y, pos.y * rotationTrig.x + pos.x * rotationTrig.y);
	}
	
	static float2 getReceiverPlaneDepthBias(float3 shadowCoord) {
		float2 biasUV;
		float3 dx = dfdx (shadowCoord);
		float3 dy = dfdy (shadowCoord);

		biasUV.x = dy.y * dx.z - dx.y * dy.z;
		biasUV.y = dx.x * dy.z - dy.x * dx.z;
		biasUV *= 1.0f / ((dx.x * dy.y) - (dx.y * dy.x));
		return biasUV;
	}
	
	
	static float2 findBlocker(texture2d_array<float> shadowMap,
							  sampler shadowMapSampler,
							  int shadowMapIndex,
							  float2 uv,
							  float depth,
							  float scale,
							  float2 searchUV,
							  float2 receiverPlaneDepthBias,
							  float2 rotationTrig,
							  int blockerSamples)
	{
		float avgBlockerDepth = 0.0;
		float numBlockers = 0.0;
		float blockerSum = 0.0;

		for (int i = 0; i < blockerSamples; ++i) {
			float2 offset = PoissonOffsets[i] * searchUV * scale;

			offset = rotate_(offset, rotationTrig);
	
			float shadowMapDepth = shadowMap.sample(shadowMapSampler,
														uv + offset,
														shadowMapIndex).r;

			float biasedDepth = depth;
			return shadowMapDepth;
			if (shadowMapDepth < biasedDepth)
			{
				blockerSum += shadowMapDepth;
				numBlockers += 1.0;
			}
		}

		avgBlockerDepth = blockerSum / numBlockers;

		return float2(avgBlockerDepth, numBlockers);
	}
	
	float calculateDirLightShadow(texture2d_array<float> shadowMap,
								  sampler shadowMapSampler,
								  int shadowMapIndex,
								  float3 const projCoords,
								  float NdotL,
								  float2 kernelSize,
								  int sampleCount,
								  float2 receiverPlaneDepthBias)
	{
		if (!isInLightFrustum(projCoords)) {
			return 1.0;
		}
		
		
#if 0
		float const closestDepth = shadowMap.sample(shadowMapSampler,
													projCoords.xy,
													shadowMapIndex).r;
		
		// get depth of current fragment from light's perspective
		float const currentDepth = projCoords.z;
		float shadow = currentDepth > closestDepth  ? 0.0 : 1.0;

		return shadow;
		
		
#elif 0
		float const currentDepth = projCoords.z;
		
		float shadow = 0.0;
		float2 const sampleOffset = (sampleCount - 1) / 2;
		for (int x = 0; x < 4; ++x) {
			for (int y = 0; y < 4; ++y) {
				float const closestDepth = shadowMap.sample(shadowMapSampler,
															projCoords.xy + (float2(x, y) - sampleOffset) * kernelSize,
															shadowMapIndex).r;
				shadow += currentDepth > closestDepth ? 1.0 : 0.0;
			}
		}
		shadow /= 25.0;
		return 1 - shadow;
#elif 1
		
		float const depth = projCoords.z;
		float2 const Softness = 6 * kernelSize;
		float2 searchSize = Softness * saturate(depth - .02) / depth;
		
		float random = fract(100000 * sin(projCoords.x + projCoords.y));
		float2 const rotationTrig = float2(cos(random), sin(random));
		
		auto [avgBlockerDepth, numBlockers] = findBlocker(shadowMap,
														  shadowMapSampler,
														  shadowMapIndex,
														  projCoords.xy,
														  depth,
														  2,
														  searchSize,
														  receiverPlaneDepthBias,
														  rotationTrig,
														  32);
		
		return avgBlockerDepth;
		return numBlockers / 32;
		
		
#else
		
		float2 const poissonDisk[4] = {
		  float2( -0.94201624, -0.39906216 ),
		  float2( 0.94558609, -0.76890725 ),
		  float2( -0.094184101, -0.92938870 ),
		  float2( 0.34495938, 0.29387760 )
		};
		
		
		float shadow = 0;
		for (int i = 0; i < 4; ++i) {
			float const closestDepth = shadowMap.sample(shadowMapSampler,
														projCoords.xy + poissonDisk[i] / 700.0,
														shadowMapIndex).r;
			if (closestDepth  <  projCoords.z) {
				shadow += 1;
			}
		}

		return 1 - shadow / 4;
  

		
#endif
	}

	float calculateDirLightCascadedShadow(texture2d_array<float> shadowMaps,
										  sampler shadowMapSampler,
										  int shadowMapOffset,
										  int numCascades,
										  float4x4 device const* lightSpaceTransforms,
										  float4 worldPosition,
										  float NdotL)
	{
		
		float2 const texelSize = 1.0 / 512;
		int const sampleCount = 5;
		
		
		
		
//		float3 coordCascade0 = getShadowCoord_SingleCascade(wpos);
//		receiverPlaneDepthBiasCascade0 = getReceiverPlaneDepthBias(coordCascade0.xyz);
//		float biasMultiply = dot(cascadeWeights, unity_ShadowCascadeScales);
//		receiverPlaneDepthBias = receiverPlaneDepthBiasCascade0 * biasMultiply;
		
		
		float2 receiverPlaneDepthBias;
		{
			float4 const positionLightSpace = lightSpaceTransforms[shadowMapOffset] * worldPosition;
			float3 const projLightCoords = calculateLightProjection(positionLightSpace);
			receiverPlaneDepthBias = getReceiverPlaneDepthBias(projLightCoords);
		}
		
		
		
		float shadow = 1;
		for (int j = numCascades - 1; j >= 0; --j) {
			
			int const shadowMapIndex = shadowMapOffset + j;
			
			float2 const invFrustumSize = 0.5 * float2(lightSpaceTransforms[shadowMapIndex][0][0],
													   lightSpaceTransforms[shadowMapIndex][1][1]);
		
			float2 const kernelSize = 2000 * invFrustumSize * texelSize;
			
			float4 const positionLightSpace = lightSpaceTransforms[shadowMapIndex] * worldPosition;
			float3 const projLightCoords = calculateLightProjection(positionLightSpace);
			bool const isInFrustum = isInLightFrustum(projLightCoords);
			if (isInFrustum) {
				shadow = calculateDirLightShadow(shadowMaps,
												 shadowMapSampler,
												 shadowMapIndex,
												 projLightCoords,
												 NdotL,
												 kernelSize,
												 sampleCount,
												 receiverPlaneDepthBias);
			}
			
			receiverPlaneDepthBias *= 2;
		}
		return shadow;
	}

	constant float3 shadowVizColors[10] = {
		float3(1.0, 0.0, 0.0),
		float3(1.0, 0.5, 0.0),
		float3(1.0, 1.0, 0.0),
		float3(0.5, 1.0, 0.0),
		float3(0.0, 1.0, 0.5),
		float3(0.0, 1.0, 1.0),
		float3(0.0, 0.5, 1.0),
		float3(0.0, 0.0, 1.0),
		float3(0.5, 0.0, 1.0),
		float3(1.0, 0.0, 1.0)
	};
	
	float3 visualizeShadowCascade(int shadowMapOffset,
								  int numCascades,
								  float4x4 device const* lightSpaceTransforms,
								  float4 worldPosition)
	{
		float3 shadowViz = 0.5;
		for (int j = numCascades - 1; j >= 0; --j) {
			int const lightMapIndex = shadowMapOffset + j;
			
			float4 const positionLightSpace = lightSpaceTransforms[lightMapIndex] * worldPosition;
			float3 const projLightCoords = calculateLightProjection(positionLightSpace);
			bool const isInFrustum = isInLightFrustum(projLightCoords);
			if (isInFrustum) {
				shadowViz = shadowVizColors[j];
			}
		}
		return shadowViz;
	}
}
