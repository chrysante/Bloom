#ifndef BLOOM_APPLICATION_INPUTEVENT_H
#define BLOOM_APPLICATION_INPUTEVENT_H

#include <array>
#include <concepts>
#include <iosfwd>
#include <variant>

#include <type_traits>
#include <utl/common.hpp>
#include <vml/vml.hpp>

#include "Bloom/Application/Input.h"
#include "Bloom/Core/Debug.h"

namespace bloom {

/// Common data of all events
struct InputEventBase {
    /// Describes the currently held modifier keys
    ModFlags modifierFlags;
};

/// Common data of all mouse events
struct MouseEvent: InputEventBase {
    /// The location in window coordinates of this mouse event
    /// TODO: Document how window coordinates work
    vml::double2 locationInWindow;
};

/// Event generated by mouse clicks
struct MouseDownEvent: MouseEvent {
    /// The mouse button clicked
    MouseButton button;

    /// The number of repeated clicks
    long clickCount;
};

/// Event generated when mouse clicks are released
struct MouseUpEvent: MouseEvent {
    /// The mouse button released
    MouseButton button;
};

/// Event generated by mouse movements
struct MouseMoveEvent: MouseEvent {
    /// The offset between this and the last mouse event
    vml::double2 offset;
};

/// Event generated by mouse clicking and dragging
struct MouseDragEvent: MouseMoveEvent {
    /// The mouse button clicked
    MouseButton button;
};

/// Event generated by mouse or trackpad scrolling
struct ScrollEvent: MouseEvent {
    /// The scroll offset
    vml::double2 offset;

    /// `true` if this event was generated by a trackpad
    bool isTrackpad;
};

/// "Zoom" gesture event, probably only generated by trackpads on MacOS
struct MagnificationEvent: MouseEvent {
    double offset;
};

/// Common key event data
struct KeyEvent: InputEventBase {
    /// The key that generated the event
    Key key;

    /// ???
    int repeat;
};

/// Bitfield for dispatching events
enum struct InputEventMask : unsigned {
    None = 0,

    LeftMouseDown = 1 << 0,
    RightMouseDown = 1 << 1,
    OtherMouseDown = 1 << 2,
    MouseDown = LeftMouseDown | RightMouseDown | OtherMouseDown,

    LeftMouseUp = 1 << 3,
    RightMouseUp = 1 << 4,
    OtherMouseUp = 1 << 5,
    MouseUp = LeftMouseUp | RightMouseUp | OtherMouseUp,

    MouseMoved = 1 << 6,

    LeftMouseDragged = 1 << 7,
    RightMouseDragged = 1 << 8,
    OtherMouseDragged = 1 << 9,
    MouseDragged = LeftMouseDragged | RightMouseDragged | OtherMouseDragged,

    ScrollWheel = 1 << 10,
    Magnify = 1 << 11,

    Mouse = MouseDown | MouseUp | MouseMoved | MouseDragged | ScrollWheel |
            Magnify,

    KeyDown = 1 << 12,
    KeyUp = 1 << 13,
    Key = KeyDown | KeyUp
};

UTL_ENUM_OPERATORS(InputEventMask);

namespace internal {

template <typename E>
struct IsInputEvent: std::is_base_of<InputEventBase, std::decay_t<E>> {};

template <InputEventMask>
struct ToInputEvent;

#define BLOOM_MAP_EVENT_TYPE(Type, Event)                                      \
    template <>                                                                \
    struct ToInputEvent<InputEventMask::Type> {                                \
        using type = Event;                                                    \
    };

BLOOM_MAP_EVENT_TYPE(LeftMouseDown, MouseDownEvent)
BLOOM_MAP_EVENT_TYPE(RightMouseDown, MouseDownEvent)
BLOOM_MAP_EVENT_TYPE(OtherMouseDown, MouseDownEvent)
BLOOM_MAP_EVENT_TYPE(MouseDown, MouseDownEvent)
BLOOM_MAP_EVENT_TYPE(LeftMouseUp, MouseUpEvent)
BLOOM_MAP_EVENT_TYPE(RightMouseUp, MouseUpEvent)
BLOOM_MAP_EVENT_TYPE(OtherMouseUp, MouseUpEvent)
BLOOM_MAP_EVENT_TYPE(MouseUp, MouseUpEvent)
BLOOM_MAP_EVENT_TYPE(MouseMoved, MouseMoveEvent)
BLOOM_MAP_EVENT_TYPE(LeftMouseDragged, MouseDragEvent)
BLOOM_MAP_EVENT_TYPE(RightMouseDragged, MouseDragEvent)
BLOOM_MAP_EVENT_TYPE(OtherMouseDragged, MouseDragEvent)
BLOOM_MAP_EVENT_TYPE(MouseDragged, MouseDragEvent)
BLOOM_MAP_EVENT_TYPE(ScrollWheel, ScrollEvent)
BLOOM_MAP_EVENT_TYPE(Magnify, MagnificationEvent)
BLOOM_MAP_EVENT_TYPE(KeyDown, KeyEvent)
BLOOM_MAP_EVENT_TYPE(KeyUp, KeyEvent)
BLOOM_MAP_EVENT_TYPE(Key, KeyEvent)

#undef BLOOM_MAP_EVENT_TYPE

} // namespace internal

/// Union of all event types defined above
class BLOOM_API InputEvent {
public:
    template <typename E>
        requires(internal::IsInputEvent<E>::value)
    InputEvent(InputEventMask type, E e): _type(type), _union(std::move(e)) {
        BL_EXPECT(std::popcount((unsigned)type) == 1,
                  "Type must not be a mask");
    }

    /// Invokes \p callback on the event variant
    decltype(auto) visit(auto&& callback) const {
        return std::visit(callback, _union);
    }

    /// \Returns the event variant \p E
    /// \pre this event must be of runtime type \p E
    template <typename E>
        requires(internal::IsInputEvent<E>::value)
    E& get() {
        return std::get<E>(_union);
    }

    /// \overload
    template <typename E>
        requires(internal::IsInputEvent<E>::value)
    E const& get() const {
        return std::get<E>(_union);
    }

    /// Invokes \p callback on the event if the event is not marked handled and
    /// \p Mask matches the event type
    ///
    /// If \p callback returns a bool, this event will be marked handled if the
    /// callback returns `true`
    template <InputEventMask Mask,
              typename E = typename internal::ToInputEvent<Mask>::type,
              std::invocable<E const> Callback>
    void dispatch(Callback&& callback) {
        if (!(Mask & _type) || handled()) {
            return;
        }
        if constexpr (std::predicate<Callback, E const>) {
            _handled = std::invoke(callback, std::get<E>(_union));
        }
        else {
            std::invoke(callback, std::get<E>(_union));
        }
    }

    /// \overload for const. Cannot mark events as handled due to constness
    template <InputEventMask Mask,
              typename E = typename internal::ToInputEvent<Mask>::type,
              std::invocable<E const> Callback>
    void dispatch(Callback&& callback) const
        requires(!std::predicate<Callback, E const>)
    {
        if (!(Mask & _type) || handled()) {
            return;
        }
        std::invoke(callback, std::get<E>(_union));
    }

    /// \Returns the runtime type of this event
    InputEventMask type() const { return _type; }

    /// \Returns `true` if this event was marked as handled by a handler
    bool handled() const { return _handled; }

    /// \Returns the events modifier flags
    ModFlags modifierFlags() const {
        return visit([](auto& e) { return e.modifierFlags; });
    }

private:
    friend class Application;
    friend class Input;
    using EventUnion =
        std::variant<MouseEvent, MouseDownEvent, MouseUpEvent, MouseMoveEvent,
                     MouseDragEvent, ScrollEvent, MagnificationEvent, KeyEvent>;
    InputEventMask _type;
    EventUnion _union;
    bool _handled = false;
};

} // namespace bloom

#endif // BLOOM_APPLICATION_INPUTEVENT_H
